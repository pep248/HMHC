function segment=kinematic(segment,t,q)

nb_step=length(t);
x=[1;0;0] ; y=[0;1;0] ; z=[0;0;1];


Euler_angle=q(4:6,:)*pi/180;
pos=zeros(6,nb_step);
for k=1:nb_step
    pos(:,k)=CoM_pos_orientation(segment,q(:,k));
end
%% Computation of the derivative of euler angle
Euler_vel=zeros(3,nb_step);
for k=1:nb_step
    for i=1:3
        if (k==1)||( abs( q(i+3,k)-q(i+3,k-1) ) > 150 )
            Euler_vel(i,k)=(Euler_angle(i,k+1)-Euler_angle(i,k)) / (t(k+1)-t(k));
        elseif (k==nb_step)||( abs( q(i+3,k+1)-q(i+3,k) ) > 150 )
            Euler_vel(i,k)=(Euler_angle(i,k)-Euler_angle(i,k-1)) / (t(k)-t(k-1));
        else
            Euler_vel(i,k)=(Euler_angle(i,k+1)-Euler_angle(i,k-1)) / (t(k+1)-t(k-1));
        end
    end
end

%% Computation of the angular velocity
Omega=zeros(3,nb_step);
for k=1:nb_step
    Rx=rot_x(q(4,k)*pi/180);
    Ry=rot_x(q(4,k)*pi/180)*rot_y(q(5,k)*pi/180);
    %Rz=rot_x(q(4,k)*pi/180)*rot_y(q(5,k)*pi/180)*rot_z(q(6,k)*pi/180);
    Omega(:,k)=Euler_vel(1,k)*x + Euler_vel(2,k)*Rx*y + Euler_vel(3,k)*Ry*z;
end

%% Computation of the secod derivative of euler angle
Euler_acc=zeros(3,nb_step);
for k=1:nb_step
    for i=1:3
        if (k==1)
            Euler_acc(i,k)=(Euler_vel(i,k+1)-Euler_vel(i,k)) / (t(k+1)-t(k));
        elseif (k==nb_step)
            Euler_acc(i,k)=(Euler_vel(i,k)-Euler_vel(i,k-1)) / (t(k)-t(k-1));
        else
            Euler_acc(i,k)=(Euler_vel(i,k+1)-Euler_vel(i,k-1)) / (t(k+1)-t(k-1));
        end
    end
end

%% Computation of the angular acceleration
Omega_d=zeros(3,nb_step);
for k=1:nb_step
    
    Rx=rot_x(q(4,k)*pi/180);
    Ry=rot_x(q(4,k)*pi/180)*rot_y(q(5,k)*pi/180);
    %Rz=rot_x(q(4,k)*pi/180)*rot_y(q(5,k)*pi/180)*rot_z(q(6,k)*pi/180);
    
    Rx_diff=rot_x(q(4,k)*pi/180 + pi/2) * Euler_vel(1,k);
    Ry_diff=rot_x(q(4,k)*pi/180 + pi/2)*rot_y(q(5,k)*pi/180) * Euler_vel(1,k)...
        + rot_x(q(4,k)*pi/180)*rot_y(q(5,k)*pi/180 + pi/2 ) * Euler_vel(2,k);
    %Rz_diff=rot_x(q(4,k)*pi/180)*rot_y(q(5,k)*pi/180)*rot_z(q(6,k)*pi/180); %not done yet
    
    Omega_d(:,k)=Euler_acc(1,k)*x + Euler_acc(2,k)*Rx*y + Euler_acc(3,k)*Ry*z ...
        + Euler_vel(2,k)*Rx_diff*y + Euler_vel(3,k)*Ry_diff*z;
end

%% Computation of the marker vel and acc
marker_pos=q(1:3,:)*1e-3;
[marker_vel,marker_acc]=time_diff(q,t);

%% Computation of the CoM vel and acc
CoM_vel=zeros(3,nb_step); CoM_acc=CoM_vel;
for k=1:nb_step
    CoM_pos=pos(1:3,k);
    S=CoM_pos-marker_pos(1:3,k);
    
    CoM_vel=marker_vel+cross(Omega,S);
    CoM_acc=marker_acc+cross(Omega_d,S)+mrot(Omega)*cross(Omega,S);
end

vel=[CoM_vel;Omega];
acc=[CoM_acc;Omega_d];

segment.pos=pos;
segment.vel=vel;
segment.acc=acc;


end